{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport GoogleProvider from \"next-auth/providers/google\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    CredentialsProvider({\n      name: \"Code\",\n      credentials: {\n        code: { label: \"Code\", type: \"text\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.code) return null;\n        try {\n          const res = await fetch(\n            `${process.env.NEXT_PUBLIC_API_URL}/auth/code/verification`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({ code: credentials.code }),\n              headers: { \"Content-Type\": \"application/json\" },\n            }\n          );\n          const user = await res.json();\n\n          if (res.ok && user) {\n            return user;\n          }\n        } catch (error) {\n          return null;\n        }\n\n        return null;\n      },\n    }),\n    GoogleProvider({\n      authorization: { params: { access_type: \"offline\", prompt: \"consent\" } },\n    }),\n  ],\n  callbacks: {\n    async signIn({ user, account }) {\n      if (account?.provider === \"google\") {\n        try {\n          const response = await fetch(\n            `${process.env.NEXT_PUBLIC_API_URL}/auth/google`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({\n                email: user.email,\n                avatarUrl: user.image,\n              }),\n              headers: { \"Content-Type\": \"application/json\" },\n            }\n          );\n\n          if (!response.ok) {\n            throw new Error(\"Failed to authenticate with backend\");\n          }\n          const data = await response.json();\n\n          user.accessToken = data.accessToken as string;\n          user.refreshToken = data.refreshToken as string;\n          user.userState = data.userState as \"old\" | \"new\";\n\n          return true;\n        } catch (error) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    async jwt({ token, user, account }) {\n      if (account && user) {\n        // Première connexion\n        return {\n          ...token,\n          accessToken: user.accessToken,\n          refreshToken: user.refreshToken,\n          userState: user.userState,\n          expiresAt: Date.now() + 3600 * 1000, // Supposons que le token expire dans 1 heure\n        };\n      }\n\n      // Vérifier si le token a expiré\n      if (Date.now() < (token.expiresAt as number)) {\n        return token;\n      }\n\n      // Le token a expiré, essayons de le rafraîchir\n      try {\n        const response = await fetch(\n          `${process.env.NEXT_PUBLIC_API_URL}/api/auth/refresh/token`,\n          {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ refreshToken: token.refreshToken }),\n          },\n        );\n\n        if (!response.ok) {\n          throw new Error(\"Échec du rafraîchissement du token\");\n        }\n\n        const refreshedTokens = await response.json();\n\n        return {\n          ...token,\n          accessToken: refreshedTokens.accessToken,\n          refreshToken: refreshedTokens.refreshToken ?? token.refreshToken, // Garder l'ancien refresh token si un nouveau n'est pas fourni\n          expiresAt: Date.now() + 3600 * 1000, // Mettre à jour l'expiration\n        };\n      } catch (error) {\n        return {\n          ...token,\n          error: \"RefreshAccessTokenError\",\n        };\n      }\n    },\n    async session({ session, token }) {\n      session.user.accessToken = token.accessToken as string;\n      session.user.refreshToken = token.refreshToken as string;\n      session.user.userState = token.userState as \"old\" | \"new\";\n      session.error = token.error as \"RefreshAccessTokenError\" | undefined;\n\n      return session;\n    },\n  },\n  pages: {\n    signIn: \"/auth\",\n  },\n  debug: process.env.NODE_ENV === \"development\",\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/middleware.ts"],"sourcesContent":["import { NextResponse, NextRequest } from \"next/server\";\n\nimport { auth, signOut } from \"@/auth\";\n\nexport async function middleware(request: NextRequest) {\n  const session = await auth();\n  \n  const { pathname } = request.nextUrl;\n\n  // Gestion de l'erreur de rafraîchissement du token\n  if (session?.error === \"RefreshAccessTokenError\") {\n    // Utiliser signOut pour déconnecter l'utilisateur\n    await signOut({ redirectTo: \"/auth\" });\n\n    return NextResponse.redirect(new URL(\"/auth\", request.url));\n  }\n\n  if (!session && !pathname.startsWith(\"/auth\")) {\n    return NextResponse.redirect(new URL(\"/auth\", request.url));\n  }\n\n  if (session && pathname.startsWith(\"/auth\")) {\n    return NextResponse.redirect(new URL(\"/\", request.url));\n  }\n\n  if (\n    session &&\n    session.user.userState === \"new\" &&\n    !pathname.startsWith(\"/auth\")\n  ) {\n    return NextResponse.redirect(new URL(\"/auth?step=3\", request.url));\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    \"/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$|$|faqs|about|help|terms|auth|api/auth).*)\",\n    \"/workspaces/:path*\",\n  ],\n};\n"],"names":[],"mappings":";;;;;;;;;;AAIO,eAAe,WAAW,OAAoB;IACnD,MAAM,UAAU,MAAM,CAAA,GAAA,oGAAA,CAAA,OAAI,AAAD;IAEzB,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,mDAAmD;IACnD,IAAI,SAAS,UAAU,2BAA2B;QAChD,kDAAkD;QAClD,MAAM,CAAA,GAAA,oGAAA,CAAA,UAAO,AAAD,EAAE;YAAE,YAAY;QAAQ;QAEpC,OAAO,oTAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,SAAS,QAAQ,GAAG;IAC3D;IAEA,IAAI,CAAC,WAAW,CAAC,SAAS,UAAU,CAAC,UAAU;QAC7C,OAAO,oTAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,SAAS,QAAQ,GAAG;IAC3D;IAEA,IAAI,WAAW,SAAS,UAAU,CAAC,UAAU;QAC3C,OAAO,oTAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,IACE,WACA,QAAQ,IAAI,CAAC,SAAS,KAAK,SAC3B,CAAC,SAAS,UAAU,CAAC,UACrB;QACA,OAAO,oTAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,gBAAgB,QAAQ,GAAG;IAClE;IAEA,OAAO,oTAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;QACA;KACD;AACH"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}